function main()
%xcell=1;
%num_thr=1;
pthmin=1E-18;
pthmax=1E15;

%pcat=4;
%qmin=3;
nbg=0;


ipmin=fix(log(pthmin)/0.05);
ipmax=fix(log(pthmax)/0.05);
%ipmin=-500
%ipmax=0

name='gauss_cat1_dc1_k_194.dat';

ijt=0; % Number of events in Σο since t0
ijk=0; % Number of events in Σ since t_in
data = importfile(name,1,inf);
warning off
tt=double(size(data));
ltt=double(size(data));
lt2=double(size(data));
lnn=double(size(data));
j1=double(size(data));
t2=int32(size(data));
t=int32(size(data));
warning on

for i=1:size(data,1)
    tt=data.tt(i);
    ltt=data.ltt(i);
    lnn=data.lnn(i);
    j1=data.j1(i);
        if(j1==0)
            nbg=nbg+1;
        end
        ijt=ijt+1;
        t2(ijt)=tt/(3600*24); % time unit into days
        lt2(ijt)=ltt;%!+(-2*0.001)*rand()+0.001
        ln2(ijt)=lnn;%!+(-2*0.001)*rand()+0.001
        ijk=ijk+1;
        t(ijk)=tt/(3600*24) ;
        lt(ijk)=ltt;
        ln(ijk)=lnn;
end
tic;

npt=i-1;
%disp(nbg);

OFFSET=-ipmin +1;
% nlink(OFFSET+1-ipmin+ipmax)=int32(0); %! numero connessioni
% kr(OFFSET+1-ipmin+ipmax)=int32(0); %! numero inizio della radice
nlink=int32(zeros(1,-ipmin + ipmax +1)); %! numero connessioni
kr=int32(zeros(1,-ipmin + ipmax +1)); %! numero inizio della radice

% for ip=ipmin:ipmax
%     nlink(ip+OFFSET)=int32(0); %! numero connessioni
%     kr(ip+OFFSET)=int32(0); %! numero inizio della radice
% end

%ipmaxt=ipmax;
for i=2:ijk
    ixxx=lt(i);
    iyyy=ln(i);
    ipmaxt=ipmin;
    for indicej=i-1:-1:1
        %do j=i-1,1,-1
        l1=metric([ ixxx iyyy], [lt(indicej) ln(indicej)]);
        %l1=metric([ixxx iyyy],[lt(indicej) ln(indicej)]);
        %disp(l1)
        ipf=max(ipmin,-fix(l1/0.1));
        ipmaxt=max(ipf,ipmaxt);
        for ip=ipmin:ipf
            nlink(ip+OFFSET)=nlink(ip+OFFSET)+1;
        end
    end
    for ip=ipmaxt+1:ipmax
        kr(ip+OFFSET)=kr(ip+OFFSET)+1;
    end
end


%max(kr)
%histogram(kr)
num_x=25;
num_y=25;
%write(num_x,73)int(qmin*10)
%write(num_y,72)pcat!int(a(2)*100)
%write(num_z,73)int(a(7)*100)

elapsed_time=toc;
disp("Elapsed time is " +  elapsed_time + " seconds.")
nome1=['1f_zmxy_qmin' num2str(num_x) '_cat_' num2str(num_y) '.dat'];
fileID = fopen(nome1,'w');


for ip=ipmax:-1:ipmin+10
    if(kr(ip+OFFSET)==1)
        break
    end
    if(nlink(ip-10+OFFSET)>nlink(ip+OFFSET))
        zmexp=((double(kr(ip+OFFSET))-double(kr(ip-10+OFFSET)))/(double(nlink(ip-10+OFFSET))-double(nlink(ip+OFFSET))));
        if (abs(zmexp)>1e-6)
            disp(zmexp);
        end
        %zmexp=(kr(ip)-kr(ip-10))*1d0/(nlink(ip-10)-nlink(ip))
        %%fprintf(fileID,'%12d %fL %12d\n',kr(ip+OFFSET),zmexp,nlink(ip+OFFSET));
    end
end
fclose(fileID);
end


function dr=metric(p1,p2)
dr=sqrt((p1(1)-p2(1))^2+(p1(2)-p2(2))^2) ; % Euclidean distance
%dr=pdist([p1; p2],'euclidean');
% 'euclidean'	Euclidean distance (default).
% 'squaredeuclidean'	Squared Euclidean distance. (This option is provided for efficiency only. It does not satisfy the triangle inequality.)
% 'seuclidean'	Standardized Euclidean distance. Each coordinate difference between observations is scaled by dividing by the corresponding element of the standard deviation, S = std(X,'omitnan'). Use DistParameter to specify another value for S.
% 'mahalanobis'	 Mahalanobis distance using the sample covariance of X, C = cov(X,'omitrows'). Use DistParameter to specify another value for C, where the matrix C is symmetric and positive definite.
% 'cityblock'	 City block distance.
% 'minkowski' Minkowski distance. The default exponent is 2. Use DistParameter to specify a different exponent P, where P is a positive scalar value of the exponent.
% 'chebychev' Chebychev distance (maximum coordinate difference).
% 'cosine'	 One minus the cosine of the included angle between points (treated as vectors).
% 'correlation' One minus the sample correlation between points (treated as sequences of values).
% 'hamming'	Hamming distance, which is the percentage of coordinates that differ.
% 'jaccard' One minus the Jaccard coefficient, which is the percentage of nonzero coordinates that differ.
% 'spearman'	 One minus the sample Spearman's rank correlation between observations (treated as sequences of values).
end

function data = importfile(filename, startRow, endRow)
%IMPORTFILE Import numeric data from a text file as a matrix.
%   DATA = IMPORTFILE(FILENAME)
%   Reads data from text file FILENAME for the default selection.
%
%   DATA = IMPORTFILE(FILENAME, STARTROW, ENDROW)
%   Reads data from rows STARTROW through ENDROW of text file FILENAME.
%
% Example:
%   data = importfile('p4.dat', 1, 31045);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2022/02/17 12:18:50

%% Initialize variables.
if nargin<=2
    startRow = 1;
    endRow = inf;
end

%% Format for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%21d%18f%17f%17d%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this code. If an error occurs for a different file, try regenerating the code from the Import Tool.
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', '', 'WhiteSpace', '', 'TextType', 'string', 'HeaderLines', startRow(1)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
for block=2:length(startRow)
    frewind(fileID);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', '', 'WhiteSpace', '', 'TextType', 'string', 'HeaderLines', startRow(block)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
    for col=1:length(dataArray)
        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
    end
end

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post processing code is included. To generate code which works for unimportable data, select unimportable cells in a file and regenerate the script.

%% Create output variable
data = table(dataArray{1:end-1}, 'VariableNames', {'tt','ltt','lnn','j1'});


end



